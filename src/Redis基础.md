### Redis 基础知识

#### Redis支持的数据结构

- string    

    存储key-value类型数据,如: name "quan"  

- hash
    存储结构化对象
    
    person name "quan" person age "22"
    类似如下结构:
    ```
    person -> name = "quan"
           -> age = "22"
    ```
    
- list
    
    将数据存放在列表中，实现队列一样的数据操作

- set
    
    将数据存放在集合中，不允许存在重复的键值

- sorted set

    实现有序集合，不允许存在重复的键值，每个键值会关联上分数，redis会根据分数来排序键值
   

#### Redis与Memcached的主要差异

- Redis基于单线程，Memcached基于多线程
- Redis有持久化机制，Memcached无持久化机制
- Redis支持五种数据结构，Memcached只支持string类型的数据结构

#### Redis为什么快

- 纯内存操作，IO性能最大化
- 单线程操作，避免了频繁的上下文切换
- 采用了非阻塞I/O多路复用机制

#### 如何高效的使用Redis

Redis基于单线程所以如果我们使用多条长命令可能产生阻塞，严重影响Redis性能。

以下操作我们需要避免:

- 一次只运行一条命令
- 拒绝长（慢）命令

#### Redis 过期数据删除策略

1. 定期删除

定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。

2. 惰性删除

在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。

3.内存淘汰策略

在redis.conf中可设置内存淘汰策略 

- noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。
 
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。推荐使用，目前项目在用这种。
 
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。应该也没人用吧，你不删最少使用Key,去随机删。
 
- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐

- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。依然不推荐
 
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。不推荐

